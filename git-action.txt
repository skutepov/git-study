Базовые операции

Play Video

Микро-конспект  Порядок работы при ветвлении:  
1. Создаем "новую ветку", пишем код. 
2. Тестируем "новую ветку". 
3. Мерджим "мастер" в "новую ветку". 
4. Тестируем как работает "новая ветка" с "мастером". 
5. Мерджим "новую ветку" в "мастер". 
6. Удаляем "новую ветку" т.к. она больше не нужна.

Откат изменений кода

микро-конспект discard - удалить все неотправленные в локальный репозиторий изменения 
revert - откатить существующие локальные комиты 
hard reset - удалить несколько последних комитов в локальный репозиторий

Работа с ветками

Микро-конспект  Порядок работы при ветвлении:  
1. Создаем "новую ветку", пишем код. 
2. Тестируем "новую ветку". 
3. Мерджим "мастер" в "новую ветку". 
4. Тестируем как работает "новая ветка" с "мастером". 
5. Мерджим "новую ветку" в "мастер". 
6. Удаляем "новую ветку" т.к. она больше не нужна.


Распространенные ошибки. Часть 1

Мини-конспект. Ошибка 1. Боязнь создания новых веток. 
Правильно - создавать новые ветки для добавления в программу новых функций, по завершению их разработки Merge новую функцию в основную программу. Ошибка 2. Добавлять в репозиторий "бинарники" (.exe-файлы, откомпилированную программу). 
Правильно - пользоваться функцией Ignore (то есть не комитить выбранные файлы/папки). 
Нажать Ignore нужных файлов и выполнить Commit для файла .gitignore.

Микро-конспект  1. Для каждого изменения делать новую ветку, которую по завершению сливать в мастер. 
2. Не нужно комитить скомпилированные файлы (использовать команду Ignore). 
3. При создании "новой ветки" не нужно удалять файлы "мастера" перенесенные в "новую ветку", т.к. при последующем слиянии "новой ветки" с "мастером" эти файлы будут удалены из "мастера". 
4. Избегать больших коммитов. Для разных логических изменений (разных файлов) - разные комиты.  
+ В коментарии к мелкому коммиту легче описать изменения 
+ По коммитам можно откатить изменения 
5. Использовать Cherry-pick - позволяет подтянуть только тот комит (Log) что нужен не сливая ветки полностью. Супер фича !

БлагоДарю Михаилу за микро-конспект, по предыдущим урокам списал, по ошибкам решил написать свой. Мини-конспект. Ошибка 3. При создании новой ветки удалять файлы основной программы перенесенные в новую ветку. При последующем слиянии новой ветки с основной программой эти файлы будут удалены из основной программы. 
Правильно - оставлять все файлы основной программы в новой ветке, даже если для этой фичи они и не нужны. Ошибка 4. Коммитить сразу большие изменения (например, работал целый день или больше), особенно если изменения относятся к совершенно разным частям проекта. 
Правильно - для разных логических изменений (разных файлов, функций и т.п.) - разные коммиты. 
Плюсы: 
+ В коментарии к мелкому коммиту легче адекватно описать изменения 
+ Можно откатить одно изменение, не затрагивая другого Ошибка 5. Если при написании новой фичи что-то подправили в основной программе, перейти в основную ветку и продублировать изменения. В таком случае при слиянии веток может выйти конфликт (можно в одной из версий допустить ошибку). 
Правильно - использовать Cherry-pick. То есть подтянуть только нужный коммит из новой фичи в основную программу, не сливая ветки полностью. Или, как я понял, можно всё-таки продублировать изменения в обоих ветках вручную, но только копипастом (внести изменения в ветке фичи - скопировать файл вообще в другое место - Check out ветку основной программы - заменить файл). Если изменения будут абсолютно идентичны, то при слиянии веток конфликта не будет. 
Но лучше всё-таки пользоваться Cherry-pick. В логах Гита автоматически будет понятно, что изменялось в программе.

Консольный git-клиент. Базовые операции

Мини-конспект. git clone - Перейти в нужную директорию (командами cd и другими, если нужно) и выполнить git clone https://github.com/{ваш путь}.git при этом создастся субдиректория по названию репозитория на гитхабе git status - показывает нужно ли что-то коммитить (точнее есть ли изменённые файлы, в т.ч. в индексе и не в индексе) git add - добавляет указанный файл в индекс (staging area) для последующего коммита git commit - коммитит файлы в индексе 
git commit -a - коммитит всё, но новые файлы только если в индексе, а изменённые и не в индексе 
git commit filename - коммитит указанный файл 
git commit -m "commit message" - сразу написать commit message, иначе откроет окно ввода коммит-сообщения, которым плохо понятно как пользоваться и из которого хрен разберёшься как выходить (оказалось нажать ESC, ввести :wq и нажать Enter) В чём разница делать add потом commit или сразу commit нужно ещё изучать дополнительно. Похоже лучше всегда делать add перед коммитом. git log - показывает лог коммитов с коммит-сообщениями Полезные ресурсы: git-scm.com

Мини-конспект. 
git branch -a - показать все ветки 
git branch love - создать ветку love 
git checkout love - переключиться в ветку love 
git push origin love - отправить ветку love в удалённый репозиторий 
git merge love (сначала переключиться на мастер) - слить ветку love с master 
git branch -d love - удалить ветку love из локального репозитория 
git push origin --delete love - удалить ветку love из удалённого репозитория 
git push origin - сделать push, так как локальные изменения в master`е мы в удалённый ещё не отправляли

Мини-конспект. 
1. Разработку лучше вести не в ветке master, а в другой ветке, например, develop, новые функции программы ветвить от develop, тестить и фиксить в develop, и только когда код отлажен до какой-то стабильной версии программы, сливать изменения в master. 
2. При этом удобно добавить тэг с номером версии и изменениями что допилили в этой версии (release notes). 
3. По тэгу легко найти нужную версию в логе, и можно по этому коммиту (вообще можно по любому коммиту) воссоздать в отдельной ветке состояние программы в этой версии.

 
